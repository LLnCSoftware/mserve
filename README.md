# mserve
Enhanced mserve load balanced solution

## Starting the Server

From the root of the repo:
```
q mserve.np.q [number of servants] [servant file to load]  [host1]  [host2] ...  -p [port number]
```

Here each "host" is an ip address or resolvable host name for each machine
available for running servants.

When no "hosts" are specified, All servants will be started on the local machine.
To include the local machine in the list of hosts, specify "localhost".

When a list of hosts is specified, servants will be started on them in a round robbin. 
When the number of servants equals the number of host names, one servant is started on each host.

## Quickstart Demo

1. Start the server in a terminal:  **q mserve\_np.q 2 servant.q -p 5000**
  This runs 2 instances of the demo server "servant.q" on the local machine, 
  with mserve\_np.q on port 5000 and the servants on 5001 and 5002.
  
2. Start the demo client in another terminal:  **q qs.q 5000**
  giving it the port number that mserve\_np.q is listening on.

3. Try a test query: 

    send "proc1 `IBM"

  This sends a message like (1234;  "proc1 `IBM)" to mserve_np.q as a serialized general list. 
  Here 1234 is an integer generated by the client, which will be echoed back, to allow matching the 
  response with its request. This message is displayed on the client console.

4. Await the response. If all goes well you will see something like:
```
send "proc1 `IBM"
(1234;"proc1 `IBM")

ID: 1234
--info--
qsvr     | `::5002
elapsed  | 4724
execution| 4724
route    | `IBM
--result--
SYM MAX      MIN          OPEN    CLOSE    AVG      VWAP     DEV      VAR     
------------------------------------------------------------------------------
IBM 99.99956 5.739275e-05 1.89879 58.87289 50.04816 50.04443 28.84313 831.9261
```

5. Understanding the response:  
5.1. The line directly under the request (1234; "proc1 `IBM") is the "q" data structure 
 that is actually sent from the  client to mserve and forwarded to the servant.
5.2. There are 3 parts to the response, the id echoed from the client, the query result,
 and a dictionary containing benchmarking information.
5.3 That infomation includes which servant the query ran on, the elapsed time of the query,
  The execution time (excludes time in queue), and the "routing string" used to help select the servant.

6. Run a series of test queries, by starting the timer: **\t 3000**
 Choose a timer interval less than the elapsed time above so that queries will be sent
 faster than they complete to build up a backlog.
 After running for a while stop the timer, and watch the backlog finish executing.
 
### What is a routing string ?

In our benchmarking experiments we are trying to determine the best way to farm out queries to a collection of servers. 
So far, we have tried 3 methods, called "dispatch algorithms", and do not have frim conclusions yet.

Originally meserve_np just sent each query to the first servant from the top the the list which was not busy.
This tended to put too many queries on the same servant, and could leave others completely unused.

So we tried sending each query to next free servant down the list from the last dispatched servant.
This distributed the queries evenly, but that actually was slower because more queries ran on newly
started servers, and so had a cold cache.

The method we are using now, computes a "routing string" from the query as a hint as to what part of the database
the query accesses, so that when a query runs on a server whos previous query and the same routing string,
the data is more likely to be in cache.

We currently use the first argument to the query as the routing string.
That was really designed for an experiment which runs against a large date-partitioned historical database
and the first argument is a date or date range.

### Example Sequence Diagram

The diagram below shows the messages exchanged in the demo above

[ diagram goes here ]   

* When you run 'send proc1 `IBM' in the quickstart demo:
    * The message (1234; "proc1 `IBM") is sent from the client to mserve_np.
    * mserve_np sends the query to an internal function (denoted "match dispatcher")
    * which sends back a "routing string" in this case the first argument to the query: `IBM.   

2. When this message is dequeued for dispatch
    * The routing string is used to select a servant.
    * Prefer to send a query to a servant whos previous query had the same rounting string.
    * If preferred servant is not available choose any free (ie not busy) servant.
    * The message (1234; "proc1 `IBM) is forwarded to the selected servant unchanged.

3. When the servant responds with a result table
    * The message (1234; <result table>) is sent from the servant to mserve_np.

4. When mserve_np receives the result
    * msevere_np notices that the response includes only the id and result, no extra "info".
    * For that reason it provides a default "info dictionary" that reports: 
       * the routing string used
       * which servant ran the request
       * elapsed time (includes time in queue)
       * execution time (excludes time in queue)
    * If the servant had provided its own info dictionary as the 3rd item in the response  
      mserve_np would return that dictionary, with the routing string added to it.
    * The message (1234; <result table>; <info dictionary>) is sent back to the client


### --- to be deleted ---

5. Have a look at the server console (in the other terminal).
 At least the way things are configured now, mserve_np.q will log each request received from the client 
 and each response sent back as:
```
(`mservereq;(1234;"proc1 `IBM"))
(`mserversp;-8i;(1234;+`SYM`MAX`MIN`OPEN`CLOSE`AVG`VWAP`DEV`VAR!(,`IBM;,99.99956;,5.739275e-05;,1.89879;,58.87289;,50.04816;,50.0444..
```

In `mserversp the -8i is the client handle (.z.w), 1234 is the query id, and the rest is the result table.
The info dictionary is after the cutoff (..).

6. Note that you can run the same query using a list style command
```
send (`proc1; `IBM)
(3;`proc1`IBM)

ID: 3
--info--
qsvr     | `::5002
elapsed  | 4560
execution| 4559
route    | `IBM
--result--
SYM MAX      MIN          OPEN    CLOSE    AVG      VWAP     DEV      VAR     
------------------------------------------------------------------------------
IBM 99.99956 5.739275e-05 1.89879 58.87289 50.04816 50.04443 28.84313 831.9261
```
--- above to be deleted ---



## Requests and Responses

1. A **request** is a general list where the first element is an integer id 
 intended to be echoed back with the response, and the second element 
 is the query or command either as as string or general list.
 Additional items may be present in this list, and will be included in the message sent
 to the servant. Such items may be used in any way agreeed to between client and servant.
 *(id, query, option1, option2...)*


2. A **response** is a general list where the first element is an integer id
 echoed back from the request, and the second element is the result computed by the servant. 
 Additional items may be present in this list and will be included in the the message sent
 back to the client. Such items may be used in any way agreed to between client and servant.
 *(id, result, info1, info2...)*

3. When no "info" is included with the response from the servant, mserve_np.q will add its own
   **default info dictionary** which is what you see labeled "--info--" in the example output above.
   It tells you which servant your query ran on, how long it took, and the "routing string" computed
   by mserve_np.q to help choose the server to run on.

4. Because the routing string is computed by mserve_np.q rather than being sent from the client or servant,
   there is no pre-defined place to put it when "info" is being passed back from the servant. For now, the 
   routing string will be set in the 3rd item sent back from the servant, provided it is a dictionary (like the default).
   Otherwise the routing string is not reported.

5. Some of the uses envisioned for the extra "options" and "info" are:
  authorization, accounting, benchmarking, error status, and debugging.

## Secure Invocation

 We assume that our "servant" may be running an application which may need to accept 
 untrusted input, and want to prevent requests from running arbitrary code upon it.

 We accomplish that by restricting queries to invoking functions defined in global
 variables on the servant, with no recursive evaluation in their parameters.

 This is enforced in the .z.ps handler of servant.q

```
.z.ps:{
  ex:$[10=type x 1; parse x 1; x 1] ;
  fn:$[`proc1=ex 0; proc1; `proc2=ex 0; proc2; (::)] ;
  if[fn~(::); send[.z.w;] (x 0; 0N!"Error: unknown command: ", string ex 0)];
  send[.z.w] (x 0; @[fn; ex 1; {[e] 0N!"Error: ",(string ex 0), " ", e}]);
 };
send:{[h;data] if[h=0; -1 "\nresult:"; :show each data]; (neg h) data} ;
```

1. If we get a string we parse it; we leave general lists alone.
2. If our expression invokes a global function, the first position of the parsed
   command contains the function name as a symbol. We check that the function
   name is one of the two we provide: either `proc1 or `proc2.
3. If we get something else we send back an "unknown command" error.
4. In this case, both proc1 and proc2 take only a single argument,
   which will appear as the second item in the parsed command.
   We invoke the function on that item without using "eval" or "value",
   which could run injected code.
5. The "send" function above allows testing from the servant console by sending
   the request to handle zero.

## Real World Secure Invocation
 
In a real application the servant would have more than 2 api endpoints, and users
may need various roles or permissions to access them. These might also require 
validation of the arguments. 

Moreover the client would also need to implement secure invocation when receiving responses.

In addition on both the client and servant, there may be other traffic that the .z.ps handler
must direct besides these queries and responses.

### validating endpoints


### validating arguments


### accomodating other traffic



 
--------------------------------
previous content below this point

## Quickstart Demo on Linux

1. Open two terminal windows
2. In first window invoke: q mserve\_np.q 2 servant.q -p 5000
3. In second window invoke: q client.q -master 5000
4. Upon startup, client should send one query to myserve\_np.q which will forward it to a servant. 
5. It will take several seconds to get the first result, which will show some benchmarking info
   directly above the actual result.
6. Will also store all results in an internal table calld "results"
7. Once you get first result you can start the timer to run a series of them.


## Details

Nathan Perrem
First Derivatives
2013-05.22

This is a heavily modified version of Arthur Whitney's mserve solution which can be found at code.kx:
https://code.kx.com/trac/wiki/Cookbook/LoadBalancing

The purpose of mserve is to provide load balancing capabilities so that queries from one or more client
can be sent to the master who will then distribute these queries to the servants in a efficient load balanced way.
The servants will then send the results back to the master who sends the results back to the client.

The main enhancements in this version are:
  Master retains details of client queries in an internal table called queries. queries table keeps track on status/location
  of all queries.
  Master sends query (FIFO) to a servant only when that servant is available.
  Dropped connections to client or servant are now handled.
  Client sends master message as a pair - (query,callback).
    where callback is the name or definition of the client's delegated callback function. This callback will handle the returned result.

On Windows, to kick off the master, 4 servants and 4 clients, simply run the included .bat file.
On Linux, create an appropriate .sh file from the .bat file or kick off processes in separate shells.
