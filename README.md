# mserve
Enhanced mserve load balanced solution

## Starting the Server

From the root of the repo:
```
q mserve.np.q [number of servants] [servant file to load]  [host1]  [host2] ...  -p [port number]
```

Here each "host" is an ip address or resolvable host name for each machine
available for running servants.

When no "hosts" are specified, All servants will be started on the local machine.
To include the local machine in the list of hosts, specify "localhost".

When a list of hosts is specified, servants will be started on them in a round robbin. 
When the number of servants equals the number of host names, one servant is started on each host.

## Quickstart Demo

1. Start the server in a terminal:  **q mserve\_np.q 2 servant.q -p 5000**
  This runs 2 instances of the demo server "servant.q" on the local machine, 
  with mserve\_np.q on port 5000 and the servants on 5001 and 5002.
  
2. Start the demo client in another terminal:  **q qs.q 5000**
  giving it the port number that mserve\_np.q is listening on.

3. Try a test query: **send "proc1 `IBM"**
  This sends a message like (23;  "proc1 `IBM)" to mserve_np.q as a serialized general list. 
  Here 23 is an integer generated by the client, which will be echoed back, to allow matching the 
  response with its request. This message is displayed on the client console.

4. Await the response. If all goes well you will see something like:
```
send "proc1 `IBM"
(23;"proc1 `IBM")

ID: 23
--info--
qsvr     | `::5002
elapsed  | 4724
execution| 4724
route    | `IBM
--result--
SYM MAX      MIN          OPEN    CLOSE    AVG      VWAP     DEV      VAR     
------------------------------------------------------------------------------
IBM 99.99956 5.739275e-05 1.89879 58.87289 50.04816 50.04443 28.84313 831.9261
```

5. Have a look at the server console (in the other terminal).
 At least the way things are configured now, mserve_np.q will log each request received from the client 
 and each response sent back as:
```
(`mservereq;(23;"proc1 `IBM"))
(`mserversp;-8i;(23;+`SYM`MAX`MIN`OPEN`CLOSE`AVG`VWAP`DEV`VAR!(,`IBM;,99.99956;,5.739275e-05;,1.89879;,58.87289;,50.04816;,50.0444..
```

6. Note that you can run the same query using a list style command
```
send (`proc1; `IBM)
(3;`proc1`IBM)

ID: 3
--info--
qsvr     | `::5002
elapsed  | 4560
execution| 4559
route    | `IBM
--result--
SYM MAX      MIN          OPEN    CLOSE    AVG      VWAP     DEV      VAR     
------------------------------------------------------------------------------
IBM 99.99956 5.739275e-05 1.89879 58.87289 50.04816 50.04443 28.84313 831.9261
```

6. Run a series of test queries, by starting the timer: **\t 3000**
 Choose a timer interval less than the elapsed time above so that queries will be sent
 faster than they complete to build up a backlog.
 After running for a while stop the timer, and watch the backlog finish executing.
 
## Requests and Responses

1. A **request** is a general list where the first element is an integer id 
 intended to be echoed back with the response, and the second element 
 is the query or command either as as string or general list.
 Additional items may be present in this list, and will be included in the message sent
 to the servant. Such items may be used in any way agreeed to between client and servant.
 *(id, query, option1, option2...)*


2. A **response** is a general list where the first element is an integer id
 echoed back from the request, and the second element is the result computed by the servant. 
 Additional items may be present in this list and will be included in the the message sent
 back to the client. Such items may be used in any way agreed to between client and servant.
 *(id, result, info1, info2...)*

3. When no "info" is included with the response from the servant, mserve_np.q will add its own
   **default info dictionary** which is what you see labeled "--info--" in the example output above.
   It tells you which servant your query ran on, how long it took, and the "routing string" computed
   by mserve_np.q to help choose the server to run on.

4. Because the routing string is computed by mserve_np.q rather than being sent from the client or servant,
   there is no pre-defined place to put it in the "info" to be passed back. For now, the routing string
   will be set in the 3rd item sent back from the servant, provided it is a dictionary (like the default).
   Otherwise the routing string is not reported.

5. Some of the uses envisioned for the extra "options" and "info" are:
  authorization, accounting, benchmarking, error status, and debugging.


## Secure Invocation

 We assume that our "servant" may be running an application which may need to accept 
 untrusted input, and want to prevent requests from running arbitrary code upon it.

 We accomplish that by restricting queries to invoking functions defined in global
 variables on the servant, with no recursive evaluation in their parameters.

 This is enforced in the .z.ps handler of servant.q

```
.z.ps:{
  ex:$[10=type x 1; parse x 1; x 1] ;
  fn:$[`proc1=ex 0; proc1; `proc2=ex 0; proc2; (::)] ;
  if[fn~(::); send[.z.w;] (x 0; 0N!"Error: unknown command: ", string ex 0)];
  send[.z.w] (x 0; @[fn; ex 1; {[e] 0N!"Error: ",(string ex 0), " ", e}]);
 };
send:{[h;data] if[h=0; -1 "\nresult:"; :show each data]; (neg h) data} ;
```

1. If we get a string we parse it; we leave general lists alone.
2. If our expression invokes a global function, the first position of the parsed
   command contains the function name as a symbol. We check that the function
   name is one of the two we provide: either `proc1 or `proc2.
3. If we get something else we send back an "unknown command" error.
4. In this case, both proc1 and proc2 take only a single argument,
   which will appear as the second item in the parsed command.
   We invoke the function on that item without using "eval" or "value",
   which could run injected code.
5. The "send" function above allows testing from the servant console by sending
   the request to handle zero.

## Real World Secure Invocation
 
In a real application the servant would have more than 2 api endpoints, and users
may need various roles or permissions to access them. These might also require 
validation of the arguments. 

Moreover the client would also need to implement secure invocation when receiving responses.

In addition on both the client and servant, there may be other traffic that the .z.ps handler
must direct besides these queries and responses.

### validating endpoints


### validating arguments


### accomodating other traffic



 
--------------------------------
previous content below this point

## Quickstart Demo on Linux

1. Open two terminal windows
2. In first window invoke: q mserve\_np.q 2 servant.q -p 5000
3. In second window invoke: q client.q -master 5000
4. Upon startup, client should send one query to myserve\_np.q which will forward it to a servant. 
5. It will take several seconds to get the first result, which will show some benchmarking info
   directly above the actual result.
6. Will also store all results in an internal table calld "results"
7. Once you get first result you can start the timer to run a series of them.


## Details

Nathan Perrem
First Derivatives
2013-05.22

This is a heavily modified version of Arthur Whitney's mserve solution which can be found at code.kx:
https://code.kx.com/trac/wiki/Cookbook/LoadBalancing

The purpose of mserve is to provide load balancing capabilities so that queries from one or more client
can be sent to the master who will then distribute these queries to the servants in a efficient load balanced way.
The servants will then send the results back to the master who sends the results back to the client.

The main enhancements in this version are:
  Master retains details of client queries in an internal table called queries. queries table keeps track on status/location
  of all queries.
  Master sends query (FIFO) to a servant only when that servant is available.
  Dropped connections to client or servant are now handled.
  Client sends master message as a pair - (query,callback).
    where callback is the name or definition of the client's delegated callback function. This callback will handle the returned result.

On Windows, to kick off the master, 4 servants and 4 clients, simply run the included .bat file.
On Linux, create an appropriate .sh file from the .bat file or kick off processes in separate shells.
